<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0051)https://adriann.github.io/programming_problems.html -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><HTML 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
   <LINK title="What's new on adriann.github.io" href="https://adriann.github.io/feed.rss" 
rel="alternate" type="application/rss+xml">   
<META http-equiv="Content-Type" content="text/html; charset=utf-8">   
<META http-equiv="Content-Style-Type" content="text/css">   
<META name="viewport" content="width=device-width, initial-scale=1.0">   
<META name="GENERATOR" content="MSHTML 11.00.10570.1001">   
<META name="author" content="Adrian Neumann (adrian_neumann@gmx.de)">   
<TITLE>Simple Programming Problems</TITLE>   
<STYLE type="text/css">
  .displayequation{margin-left:auto;margin-right:auto;}
  </STYLE>
   
<STYLE>
  .caption{font-size:66%;text-align:right;}
  .figure{float:right;padding-bottom:1em;padding-left:1em;}
  .figure>img{display:block;margin:0 auto;}
  .footnotes{font-size:80%;}
  .block{border-left:1ex solid gray;padding-left:2em;}
  li{padding:0.25em;}
  a:hover{text-shadow: 0 0 5px;}
  body{font-family:sans-serif;max-width:100ex;padding-left:3em;padding-right:2em;}
  code{font-family:Consolas, Inconsolata, Monaco, monospace;}
  p{text-align:justify;}
  </STYLE>
 </HEAD> 
<BODY>
<DIV id="header">
<H1 class="title">Simple Programming Problems</H1></DIV>
<P>Whenever I’m TA for a introductory CS class where students learn some 
programming language, I have trouble coming up with good exercises. Problems 
from <A href="http://projecteuler.net/">Project Euler</A> and the like are 
usually much too difficult for beginners, especially if they don’t have a strong 
background in mathematics.</P>
<P>This page is a collection of progressively more difficult exercises that are 
suitable for people who just started learning. It will be extended as I come up 
with new exercises. Except for the GUI questions, exercises are generally 
algorithmic and should be solvable without learning any libraries. The 
difficulty of the exercises of course somewhat depends on the programming 
language you use. The List exercises for example are more complicated in 
languages like C that don’t have build-in support for lists.</P>
<P>I suppose they are also useful, although much easier, whenever an experienced 
person wants to learn a new language.</P>
<P>This guide has been translated to Chinese by Fidel Yi. <A href="https://github.com/yisha7/SimpleProgrammingProblems">Simple 
Programming Problems in Chinese</A></P>
<H2 id="before-you-begin">Before you begin</H2>
<P>Learning to program means learning how to solve problems using code. 
Conceptually it is not very difficult to write a program that solves a problem 
that you can solve yourself. The skill you need to acquire is thinking very 
precisely about how you solve the problem and breaking it down into steps that 
are so simple that a computer can execute them. I encourage you to first solve a 
few instances of a problem by hand and think about what you did to find the 
solution. For example if the task is sorting lists, sort some short lists 
yourself. A reasonable method would be to find the smallest element, write it 
down and cross it out of the original list and repeat this process until you 
have sorted the whole list. Then you have to teach the computer 1) how to find 
the smallest element, 2) how to write it down, 3) how to cross it out, and wrap 
this in a loop. Then continue this task breakdown process until you’re confident 
you know how to write the necessary program.</P>
<P>To make good progress in your programming task, you need to test your work as 
early and as thoroughly as possible. Everybody makes mistakes while programming 
and finding mistakes in programs consumes a very large part of a programmer’s 
work-day. Finding a problem in a small and easy piece of code is much simpler 
than trying to spot it in a large program. This is why you should try to test 
each sub task you identified during your task-breakdown by itself. Only after 
you’re confident that each part works as you expect you can attempt to plug them 
together. Make sure you test the complete program as well, errors can creep in 
in the way the different parts interact. You should try to automate your tests. 
The easier it is to test your program, the freer you are in experimenting with 
changes.</P>
<P>The last important point is <EM>how</EM> you express your thoughts as code. 
In the same way that you can express the same argument in different ways in a 
normal English essay, you can express the same problem-solving method in 
different ways in code. Try for brevity. The lines that you don’t write are the 
lines where you can be sure that the don’t have bugs. Don’t be afraid to Google 
for idiomatic ways of doing the things you’d like to do (after you tried doing 
them yourself!). Remember that you don’t write the program for the computer, you 
write it for other humans (maybe a future you!). Choose names that explain 
things, add comments where these names don’t suffice. Never comment on 
<EM>what</EM> the code is doing, only write comments that explain 
<EM>why</EM>.</P>
<P>This is a bad example:</P>
<PRE><CODE>
// This function checks whether a number is even
def f(x):
  // compute x modulo 2 and check whether it is zero
  if modulo(x,2) == 0:
    // the number is even
    return True
  else:
    // the number is odd
    return False
</CODE></PRE>
<P>The exact same idea is much easier to understand if you write it like 
this:</P>
<PRE><CODE>
def is_divisible(number, divisor):
  return modulo(number, divisor) == 0

def is_even(number):
  return is_divisible(number, 2)
</CODE></PRE>
<P>Better naming and a better task breakdown make the comments obsolete. Revise 
your code just as you would revise an essay. Sketch, write, delete, reformulate, 
ask others what they think. Repeat until only the crispest possible expression 
of your idea remains. Revisit code you’ve written a while ago to see whether you 
can improve it with things you’ve learned since.</P>
<H2 id="elementary">Elementary</H2>
<OL style="list-style-type: decimal;">
  <LI>Write a program that prints ‘Hello World’ to the screen.</LI>
  <LI>Write a program that asks the user for their name and greets them with 
  their name.</LI>
  <LI>Modify the previous program such that only the users Alice and Bob are 
  greeted with their names.</LI>
  <LI>Write a program that asks the user for a number <CODE>n</CODE> and prints 
  the sum of the numbers 1 to <CODE>n</CODE></LI>
  <LI>Modify the previous program such that only multiples of three or five are 
  considered in the sum, e.g.&nbsp;3, 5, 6, 9, 10, 12, 15 for 
  <CODE>n</CODE>=17</LI>
  <LI>Write a program that asks the user for a number <CODE>n</CODE> and gives 
  them the possibility to choose between computing the sum and computing the 
  product of 1,…,<CODE>n</CODE>.</LI>
  <LI>Write a program that prints a multiplication table for numbers up to 
  12.</LI>
  <LI>Write a program that prints <EM>all</EM> prime numbers. (Note: if your 
  programming language does not support arbitrary size numbers, printing all 
  primes up to the largest number you can easily represent is fine too.)</LI>
  <LI>Write a guessing game where the user has to guess a secret number. After 
  every guess the program tells the user whether their number was too large or 
  too small. At the end the number of tries needed should be printed. I counts 
  only as one try if they input the same number multiple times 
  consecutively.</LI>
  <LI>Write a program that prints the next 20 leap years.</LI>
  <LI>Write a program that computes <math xmlns="http://www.w3.org/1998/Math/MathML" 
  display="block"><semantics><mrow><mn>4</mn><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msup><mn>10</mn><mn>6</mn></msup></munderover><mfrac><mrow><mo 
  form="prefix" stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo form="postfix" 
  stretchy="false">)</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>2</mn><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mn>4</mn><mo>⋅</mo><mo 
  form="prefix" 
  stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>1</mn><mi>/</mi><mn>3</mn><mo>+</mo><mn>1</mn><mi>/</mi><mn>5</mn><mo>−</mo><mn>1</mn><mi>/</mi><mn>7</mn><mo>+</mo><mn>1</mn><mi>/</mi><mn>9</mn><mo>−</mo><mn>1</mn><mi>/</mi><mn>11</mn><mi>…</mi><mo 
  form="postfix" stretchy="false">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">4\cdot 
  \sum_{k=1}^{10^6} \frac{(-1)^{k+1}}{2k-1} = 
  4\cdot(1-1/3+1/5-1/7+1/9-1/11\ldots).</annotation></semantics></math></LI></OL>
<H2 id="lists-strings">Lists, Strings</H2>
<P>If your language of choice doesn’t have a build in list and/or string type 
(e.g.&nbsp;you use C), these exercises should also be solvable for arrays. 
However, some solutions are very different between an array-based list (like 
C++’s <CODE>vector</CODE>) and a pointer based list (like C++’s 
<CODE>list</CODE>), at least if you care about the efficiency of your code. So 
you might want to either find a library, or investigate how to implement your 
own linked list if your language doesn’t have it.</P>
<OL style="list-style-type: decimal;">
  <LI>Write a function that returns the largest element in a list.</LI>
  <LI>Write function that reverses a list, preferably in place.</LI>
  <LI>Write a function that checks whether an element occurs in a list.</LI>
  <LI>Write a function that returns the elements on odd positions in a 
list.</LI>
  <LI>Write a function that computes the running total of a list.</LI>
  <LI>Write a function that tests whether a string is a palindrome.</LI>
  <LI>Write three functions that compute the sum of the numbers in a list: using 
  a <CODE>for</CODE>-loop, a <CODE>while</CODE>-loop and recursion. (Subject to 
  availability of these constructs in your language of choice.)</LI>
  <LI>Write a function <CODE>on_all</CODE> that applies a function to every 
  element of a list. Use it to print the first twenty perfect squares (a natural 
  number <math xmlns="http://www.w3.org/1998/Math/MathML" 
  display="inline"><semantics><mi>n</mi><annotation 
  encoding="application/x-tex">n</annotation></semantics></math> is a perfect 
  square if it can be written as <math xmlns="http://www.w3.org/1998/Math/MathML" 
  display="inline"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi><mo>*</mo><mi>m</mi></mrow><annotation 
  encoding="application/x-tex">n=m*m</annotation></semantics></math> for some 
  other natural number <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mi>m</mi><annotation 
  encoding="application/x-tex">m</annotation></semantics></math>. <math xmlns="http://www.w3.org/1998/Math/MathML" 
  display="inline"><semantics><mrow><mn>1</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>9</mn><mo>,</mo><mn>16</mn><mo>,</mo><mn>25</mn></mrow><annotation 
  encoding="application/x-tex">1,4,9,16,25</annotation></semantics></math> are 
  the first 5).</LI>
  <LI>Write a function that concatenates two lists. <CODE>[a,b,c]</CODE>, 
  <CODE>[1,2,3]</CODE> → <CODE>[a,b,c,1,2,3]</CODE></LI>
  <LI>Write a function that combines two lists by alternatingly taking elements, 
  e.g. <CODE>[a,b,c]</CODE>, <CODE>[1,2,3]</CODE> → 
  <CODE>[a,1,b,2,c,3]</CODE>.</LI>
  <LI>Write a function that merges two sorted lists into a new sorted list. 
  <CODE>[1,4,6]</CODE>,<CODE>[2,3,5]</CODE> → <CODE>[1,2,3,4,5,6]</CODE>. You 
  can do this quicker than concatenating them followed by a sort.</LI>
  <LI>Write a function that rotates a list by <CODE>k</CODE> elements. For 
  example <CODE>[1,2,3,4,5,6]</CODE> rotated by two becomes 
  <CODE>[3,4,5,6,1,2]</CODE>. Try solving this without creating a copy of the 
  list. How many swap or move operations do you need?</LI>
  <LI>Write a function that computes the list of the first 100 Fibonacci 
  numbers.</LI>
  <LI>Write a function that takes a number and returns a list of its 
digits.</LI>
  <LI>Write functions that add, subtract, and multiply two numbers in their 
  digit-list representation (and return a new digit list). If you’re ambitious 
  you can implement Karatsuba multiplication. Try <A href="https://en.wikipedia.org/wiki/Radix">different 
  bases</A>. What is the best base if you care about speed? If you couldn’t 
  completely solve the prime number exercise above due to the lack of large 
  numbers in your language, you can now use your own library for this task.</LI>
  <LI>Write a function that takes a list of numbers, a starting base 
  <CODE>b1</CODE> and a target base <CODE>b2</CODE> and interprets the list as a 
  number in base <CODE>b1</CODE> and converts it into a number in base 
  <CODE>b2</CODE> (in the form of a list-of-digits).</LI>
  <LI>Implement the following sorting algorithms: Selection sort, Insertion 
  sort, Merge sort, Quick sort, Stooge Sort. Check Wikipedia for 
  descriptions.</LI>
  <LI>Implement binary search.</LI>
  <LI>
  <P>Write a function that takes a list of strings an prints them, one per line, 
  in a rectangular frame. For example the list <CODE>["Hello", "World", "in", 
  "a", "frame"]</CODE> gets printed as:</P>
<PRE><CODE>*********
* Hello *
* World *
* in    *
* a     *
* frame *
*********</CODE></PRE></LI>
  <LI>
  <P>Write function that translates a text to Pig Latin and back. English is 
  translated to Pig Latin by taking the first letter of every word, moving it to 
  the end of the word and adding ‘ay’. “The quick brown fox” becomes “Hetay 
  uickqay rownbay oxfay”.</P></LI></OL>
<H2 id="intermediate">Intermediate</H2>
<OL style="list-style-type: decimal;">
  <LI>Write a program that outputs all possibilities to put <CODE>+</CODE> or 
  <CODE>-</CODE> or nothing between the numbers 1,2,…,9 (in this order) such 
  that the result is 100. For example 1 + 2 + 3 - 4 + 5 + 6 + 78 + 9 = 100.</LI>
  <LI>Write a program that takes the duration of a year (in fractional days) for 
  an imaginary planet as an input and produces a leap-year rule that minimizes 
  the difference to the planet’s solar year.</LI>
  <LI>Implement a data structure for graphs that allows modification (insertion, 
  deletion). It should be possible to store values at edges and nodes. It might 
  be easiest to use a dictionary of (node, edgelist) to do this.</LI>
  <LI>Write a function that generates a DOT representation of a graph.</LI>
  <LI>Write a program that automatically generates essays for you. 
  <OL style="list-style-type: decimal;">
    <LI>Using a sample text, create a directed (multi-)graph where the words of 
    a text are nodes and there is a directed edge between <CODE>u</CODE> and 
    <CODE>v</CODE> if <CODE>u</CODE> is followed by <CODE>v</CODE> in your 
    sample text. Multiple occurrences lead to multiple edges.</LI>
    <LI>Do a random walk on this graph: Starting from an arbitrary node choose a 
    random successor. If no successor exists, choose another random 
  node.</LI></OL></LI>
  <LI>Write a program that automatically converts English text to Morse code and 
  vice versa.</LI>
  <LI>Write a program that finds the longest palindromic substring of a given 
  string. Try to be as efficient as possible!</LI>
  <LI>Think of a good interface for a list. What operations do you typically 
  need? You might want to investigate the list interface in your language and in 
  some other popular languages for inspiration.</LI>
  <LI>Implement your list interface using a fixed chunk of memory, say an array 
  of size 100. If the user wants to add more stuff to your list than fits in 
  your memory you should produce some kind of error, for example you can throw 
  an exception if your language supports that.</LI>
  <LI>Improve your previous implementation such that an arbitrary number of 
  elements can be stored in your list. You can for example allocate bigger and 
  bigger chunks of memory as your list grows, copy the old elements over and 
  release the old storage. You should probably also release this memory 
  eventually if your list shrinks enough not to need it anymore. Think about how 
  much bigger the new chunk of memory should be so that your performance won’t 
  be killed by allocations. Increasing the size by 1 element for example is a 
  bad idea.</LI>
  <LI>If you chose your growth right in the previous problem, you typically 
  won’t allocate very often. However, adding to a big list sometimes consumes 
  considerable time. That might be problematic in some applications. Instead try 
  allocating new chunks of memory for new items. So when your list is full and 
  the user wants to add something, allocate a new chunk of 100 elements instead 
  of copying all elements over to a new large chunk. Think about where to do the 
  book-keeping about which chunks you have. Different book keeping strategies 
  can quite dramatically change the performance characteristics of your 
  list.</LI>
  <LI>Implement a binary heap. Once using a list as the base data structure and 
  once by implementing a pointer-linked binary tree. Use it for implementing 
  heap-sort.</LI>
  <LI>Implement an unbalanced binary search tree.</LI>
  <LI>Implement a balanced binary search tree of your choice. I like (a,b)-trees 
  best.</LI>
  <LI>Compare the performance of insertion, deletion and search on your 
  unbalanced search tree with your balanced search tree and a sorted list. Think 
  about good input sequences. If you implemented an (a,b)-tree, think about good 
  values of a and b.</LI></OL>
<H2 id="advanced">Advanced</H2>
<OL style="list-style-type: decimal;">
  <LI>Given two strings, write a program that efficiently finds the longest 
  common subsequence.</LI>
  <LI>Given an array with numbers, write a program that efficiently answers 
  queries of the form: “Which is the nearest larger value for the number at 
  position <CODE>i</CODE>?”, where distance is the difference in array indices. 
  For example in the array <CODE>[1,4,3,2,5,7]</CODE>, the nearest larger value 
  for 4 is 5. After linear time preprocessing you should be able to answer 
  queries in constant time.</LI>
  <LI>Given two strings, write a program that outputs the shortest sequence of 
  character insertions and deletions that turn one string into the other.</LI>
  <LI>Write a function that multiplies two matrices together. Make it as 
  efficient as you can and compare the performance to a polished linear algebra 
  library for your language. You might want to read about <A href="https://en.wikipedia.org/wiki/Strassen_algorithm">Strassen’s 
  algorithm</A> and the effects CPU caches have. Try out different matrix 
  layouts and see what happens.</LI>
  <LI>Implement a <A href="https://en.wikipedia.org/wiki/Van_Emde_Boas_tree">van 
  Emde Boas</A> tree. Compare it with your previous search tree 
  implementations.</LI>
  <LI>Given a set of d-dimensional rectangular boxes, write a program that 
  computes the volume of their union. Start with 2D and work your way 
up.</LI></OL>
<H2 id="gui">GUI</H2>
<UL>
  <LI>Write a program that displays a bouncing ball.</LI>
  <LI>Write a <A 
  href="https://en.wikipedia.org/wiki/Memory_%28game%29">Memory</A> game.</LI>
  <LI>Write a Tetris clone</LI></UL>
<H2 id="open-ended">Open Ended</H2>
<OL style="list-style-type: decimal;">
  <LI>Write a program that plays Hangman as good as possible. For example you 
  can use a large dictionary like <A 
  href="http://wordlist.sourceforge.net/">this</A> and select the letter that 
  excludes most words that are still possible solutions. Try to make the program 
  as efficient as possible, i.e.&nbsp;don’t scan the whole dictionary in every 
  turn.</LI>
  <LI>Write a program that plays Rock, Paper, Scissors better than random 
  against a human. Try to exploit that humans are very bad at generating random 
  numbers.</LI>
  <LI>Write a program that plays Battle Ship against human opponents. It takes 
  coordinates as input and outputs whether that was a hit or not and its own 
  shot’s coordinates.</LI></OL>
<H2 id="other-collections">Other Collections</H2>
<P>Of course I’m not the first person to come up with the idea of having a list 
like this.</P>
<UL>
  <LI><A href="http://users.csc.calpoly.edu/~jdalbey/">John Dalbey</A>’s 
  collection 
  <UL>
    <LI>Several small problems <A href="http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html">Programming 
    Practice</A></LI>
    <LI>CPE 101 <A 
    href="http://users.csc.calpoly.edu/~jdalbey/101/index.html">Projects</A></LI></UL></LI>
  <LI><A href="http://codekata.pragprog.com/">Code Kata</A></LI>
  <LI><A href="http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html">99 
  Lisp Problems</A>, <A href="http://www.haskell.org/haskellwiki/99_Haskell_exercises">99 
  Haskell Problems</A>. Most of these can also be done in other languages.</LI>
  <LI><A href="http://rosettacode.org/wiki/Category:Programming_Tasks">Rosetta 
  Code Programming Tasks</A>. These come with solutions in many languages!</LI>
  <LI><A href="http://codegolf.com/competition/browse">Code Golf Challenges</A>. 
  The goal here is to solve the problem with as few characters as possible.</LI>
  <LI><A href="http://www.spoj.com/problems/classical/">SPOJ Problems</A>. This 
  is a list of more than 13000 Problems!</LI>
  <LI><A href="http://codeabbey.com/">Code Abbey</A> According to Github user 
  RodionGork, this is less mathy than Project Euler.</LI></UL>
<HR>

<DIV style="font-size: 80%; display: inline-flex; flex-wrap: wrap; justify-content: space-between;">
<P style="margin-right: 2ex;">CC-BY-SA <A 
href="mailto:adrian_neumann@gmx.de">Adrian Neumann</A> (PGP Key <A href="https://adriann.github.io/ressources/pub.asc">A0A8BC98</A>)</P>
<P style="margin-right: 1ex; margin-left: 1ex;"><A href="http://adriann.github.io/">adriann.github.io</A></P>
<P style="margin-left: 2ex;"><A 
href="https://adriann.github.io/feed.rss">RSS</A></P></DIV></BODY></HTML>
